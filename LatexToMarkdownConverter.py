# -*- coding: utf-8 -*-
"""Untitled28.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WUaUjH_5AsSehY9lSonepl9DcFshT9Dr
"""

class LatexToMarkdownConverter:
    def __init__(self, file_path, output_path="output.md"):
        self.file_path = file_path
        self.output_path = output_path

    def process_conversion(self):
        latex_content = self._read_tex_file()
        if latex_content is None:
            return

        converted_text = self._convert_all(latex_content)
        self._write_to_md_file(converted_text)

    def _read_tex_file(self):
        try:
            with open(self.file_path, 'r', encoding='utf-8') as tex_file:
                return tex_file.read().replace('\\', '\\\\')
        except FileNotFoundError:
            print(f"Error: File '{self.file_path}' not found.")
        except Exception as e:
            print(f"Error: An error occurred while reading the file: {e}")
        return None

    def _write_to_md_file(self, md_content):
        try:
            with open(self.output_path, 'w', encoding='utf-8') as md_file:
                md_file.write(md_content)
                print(f"Markdown file written to {self.output_path}")
        except Exception as e:
            print(f"Error: An error occurred while writing to the file: {e}")

    def _convert_all(self, text):
        text = self._convert_figure_to_markdow(text)
        text = self._convert_headers_style(text)
        text = self._remove_content_after_percent(text)
        text = self._detect_and_convert_latex_tables(text, self._latex_to_markdown)
        text = self._process_text(text)
        text = self._replace_citations(text)
        text = self._convert_greek_letters_to_markdown(text)
        text = self._convert_latex_special_commands_to_markdown(text)
        text = self._replace_references_in_text(text)
        text = self._create_markdown_toc_with_title_and_references(text)
        text = self._replace_glossary_heading(text)
        text = self._convert_latex_list_to_markdown(text)
        return text

    def _convert_figure_to_markdow(self, text):
      # Define a regular expression pattern to match LaTeX figure environments
      pattern = r'\\begin{figure}\[H\](.*?)\\includegraphics(?:\[[^\]]*\])?\{([^}]*)\}(.*?)\\end{figure}'

      def replace_figure(match):
          # Extract the image filename and caption
          caption = re.search(r'\\caption{((?:[^{}]|{[^{}]*})*)}', match.group(0)).group(1)
          image_filename = match.group(2)
          label = re.search(r'\\label{((?:[^{}]|{[^{}]*})*)}', match.group(0)).group(1)

          # Create the Markdown image link
          markdown_image = f"![{caption}]({image_filename})\n \n <sup>*Figure @"+ label + "@: " + caption + "*</sup>"

          return markdown_image

      # Use re.sub to find and replace figure patterns in the input text
      markdown_text = re.sub(pattern, replace_figure, text, flags=re.DOTALL)

      return markdown_text

    def _convert_headers_style(self, text):
      # Convert LaTeX section headers to Markdown headers
      text = re.sub(r'\\section\{(.*?)\}', r'# \1', text)
      text = re.sub(r'\\section*\{(.*?)\}', r'# \1', text)
      text = re.sub(r'\\subsection\{(.*?)\}', r'## \1', text)
      text = re.sub(r'\\subsubsection\{(.*?)\}', r'### \1', text)

      # Convert bold text
      text = re.sub(r'\\textbf\{(.*?)\}', r'**\1**', text)

      # Convert cursive text
      text = re.sub(r'\\textit\{(.*?)\}', r'*\1*', text)

      # Convert underline text
      text = re.sub(r'\\underline\{(.*?)\}', r'<u>\1</u>', text)

      # Convert a combination of cursive and bold text
      text = re.sub(r'\\textbf\{\\textit\{(.*?)\}\}', r'***\1***', text)

      return text

    def _remove_content_after_percent(self, text):
        """
        Processes the text by:
        1. Replacing '\\%' with '%' in numeric contexts (like '5\\%').
        2. Removing content after an unescaped '%' that is not part of a numeric percentage, until the end of the line.

        Args:
        text (str): A string to be processed.

        Returns:
        str: The processed string.
        """
        # Replace '\\%' with '%' in numeric contexts
        text = re.sub(r'(\d)\\%', r'\1%', text)

        # Use a regular expression to match unescaped '%' that is not part of a numeric percentage,
        # followed by any characters until the end of the line
        # Replace the matched portion with '%'
        cleaned_text = re.sub(r'(?<!\\)(?<!\d)%.*$', '', text, flags=re.MULTILINE)

        return cleaned_text

    def _detect_and_convert_latex_tables(self, text, convert_function):
        """
        Detects all LaTeX tables in the given text, converts them to Markdown using the provided function,
        and reinserts the converted tables back into the text.

        Args:
        text (str): Text containing LaTeX tables.
        convert_function (function): Function to convert LaTeX table to Markdown.

        Returns:
        str: Text with all LaTeX tables converted to Markdown.
        """
        # Define the regex pattern for detecting LaTeX tables
        latex_table_pattern = r'\\begin\{table\}.*?\\end\{table\}'

        # Find all LaTeX tables in the text
        matches = re.finditer(latex_table_pattern, text, re.DOTALL)
        converted_text = text

        for match in matches:
            # Extract the table
            latex_table = match.group(0)

            # Convert the table to Markdown
            markdown_table = convert_function(latex_table)

            # Replace the LaTeX table with Markdown table in the text
            converted_text = converted_text.replace(latex_table, markdown_table, 1)

        return converted_text

    def _latex_to_markdown(self, latex_table):
        """
        Converts a LaTeX table to a Markdown table, handling specific LaTeX commands like 'centering' and 'rule',
        and includes the table caption. Also handles \begin{table} command more accurately.

        Args:
        latex_table (str): A string containing the LaTeX table.

        Returns:
        str: The converted Markdown table with caption if available.
        """
        # Split the table into lines
        lines = latex_table.split('\n')

        # Initialize Markdown table parts
        header = []
        separator = []
        rows = []
        caption = ""

        # Process each line
        for line in lines:
            # Remove LaTeX specific characters like '&', '\\'
            line = line.replace('&', '|').replace('\\', '').strip()
            # Handle LaTeX-specific commands
            if 'begin{tabular}' in line or 'end{tabular}' in line or 'captionsetup{font=bf, size=small}' in line or 'small' in line or 'centering' in line or 'newcolumn' in line or 'hline' in line:
                continue
            if 'begin{table}' in line or 'end{table}' in line:
                continue  # Skipping table start and end tags
            if 'bottomrule' in line:
                continue  # Centering is default in Markdown tables
            if 'rule' in line and len(header) == 0:
                header = line.split('}')[-1].split('|')  # Extract header after \rule
                separator = ['---' for _ in header]
                continue
            if 'rule' in line and len(header) != 0:
                line = line.split('}')[-1]  # Remove \rule command
            if 'caption' in line:
                caption = re.search(r'\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', line).group(1)
                continue
            if 'label' in line:
                label = re.search(r'\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', line).group(1)
                continue

            # Skip empty lines
            if line == '':
                continue


            # Add line to rows
            rows.append(line)

        # Construct the Markdown table
        markdown_table = ['|' + '|'.join(header) + '|']
        markdown_table.append('|' + '|'.join(separator) + '|')
        for row in rows:
            markdown_table.append('|' + row + '|')

        # Adding caption properly
        if caption:
            markdown_table.append("\n <sup>*Table @"+ label + "@: " + caption + "*</sup>")

        return '\n'.join(markdown_table)

    def _process_text(self, text):
        """
        Processes the given text by:
        1. Removing the leading backslash from each line, if present.
        2. Removing any lines containing '\newpage'.
        3. Converting '\section*{GLOSSARY OF TERMS}' to '# GLOSSARY OF TERMS'.
        4. Removing occurrences of '\\' and '\\\\'.
        5. Replacing '$^{circ}$' with '°'.
        6. Replacing '\begin{equation}' with '$$' and '\end{equation}' with '$$'.

        Args:
        text (str): A string to be processed.

        Returns:
        str: The processed string.
        """
        # Split the text into lines
        lines = text.split('\n')

        # Process each line
        modified_lines = []
        for line in lines:
            # Skip lines with '\newpage'
            if '\\newpage' in line:
                continue
            # Convert '\section*{GLOSSARY OF TERMS}' to '# GLOSSARY OF TERMS'
            if line.strip() == '\\section*{GLOSSARY OF TERMS}':
                line = '# GLOSSARY OF TERMS'
            # Replace '\begin{equation}' with '$$' and '\end{equation}' with '$$'
            line = line.replace('\\begin{equation}', '$$').replace('\\end{equation}', '$$')
            # Remove occurrences of '\\' and '\\\\'
            line = line.replace('\\\\', '').replace('\\', '')
            # Replace '$^{circ}$' with '°'
            line = line.replace('$^{circ}$', '°')
            # Add the processed line to the list
            modified_lines.append(line)

        # Join the modified lines back into a single string
        return '\n'.join(modified_lines)

    def _replace_citations(self, text):
        # Dictionary to store the citations and their assigned numbers
        citation_dict = {}
        citation_num = 1

        # Function to replace citations with their respective numbers
        def replace_match(match):
            nonlocal citation_num
            citation_key = match.group(1)  # Extract the citation key from the match

            # Assign a new number if this is a new citation
            if citation_key not in citation_dict:
                citation_dict[citation_key] = citation_num
                citation_num += 1

            # Return the replacement text with the citation number
            return f"[{citation_dict[citation_key]}]"

        import re
        # Replace all occurrences of citations in the text
        return re.sub(r'cite\{([^}]+)\}', replace_match, text)

    def _convert_greek_letters_to_markdown(self, text):
        # Mapping of LaTeX Greek letters to their corresponding HTML entities or Unicode characters
        greek_letters = {
            'alpha': '&alpha;', 'beta': '&beta;', 'gamma': '&gamma;', 'delta': '&delta;',
            'epsilon': '&epsilon;', 'zeta': '&zeta;', 'eta': '&eta;', 'theta': '&theta;',
            'iota': '&iota;', 'kappa': '&kappa;', 'lambda': '&lambda;', 'mu': '&mu;',
            'nu': '&nu;', 'xi': '&xi;', 'omicron': '&omicron;', 'pi': '&pi;',
            'rho': '&rho;', 'sigma': '&sigma;', 'tau': '&tau;', 'upsilon': '&upsilon;',
            'phi': '&phi;', 'chi': '&chi;', 'psi': '&psi;', 'omega': '&omega;'
        }

        # Replace LaTeX Greek letters with their HTML entities or Unicode characters
        for latex, html_entity in greek_letters.items():
            text = re.sub(r'\$' + latex + r'\$', html_entity, text)

        return text

    def _convert_latex_special_commands_to_markdown(self, text):
        # Mapping of LaTeX special commands to their corresponding HTML entities or Unicode characters
        special_commands = {
            'rightarrow': '&rarr;', 'leftarrow': '&larr;', 'uparrow': '&uarr;', 'downarrow': '&darr;',
            'lessthan': '&lt;', 'greaterthan': '&gt;', 'leq': '&le;', 'geq': '&ge;',
            'neq': '&ne;', 'approx': '&asymp;', 'equiv': '&equiv;', 'sum': '&sum;',
            'prod': '&prod;', 'infty': '&infin;', 'sqrt': '&radic;', 'int': '&int;',
            'partial': '&part;', 'nabla': '&nabla;', 'times': '&times;', 'div': '&divide;',
            'pm': '&plusmn;', 'cdots': '&hellip;'
        }

        # Replace LaTeX special commands with their HTML entities or Unicode characters
        for command, html_entity in special_commands.items():
            text = re.sub(r'\$' + command + r'\$', html_entity, text)

        return text

    def _replace_references_in_text(self, text):
        # Function to replace references in the main text
        def replace_text_match(match, reference_dict):
            reference_key = match.group(1)
            if reference_key not in reference_dict:
                reference_dict[reference_key] = len(reference_dict) + 1
            return f"{reference_dict[reference_key]}"

        # Function to replace placeholders in captions
        def replace_caption_placeholder(match, reference_dict):
            reference_key = match.group(1)
            return f"{reference_dict.get(reference_key, '?')}"

        # Dictionary to store references and their assigned numbers
        reference_dict = {}

        # Replace references in the main text
        text = re.sub(r'ref\{([^}]+)\}', lambda match: replace_text_match(match, reference_dict), text)

        # Replace placeholders in captions
        text = re.sub(r'@([^@]+)@', lambda match: replace_caption_placeholder(match, reference_dict), text)

        return text

    def _create_markdown_toc_with_title_and_references(self, text, toc_title="Table of Contents"):
        """
        Create a table of contents for a markdown text considering only the # and ## levels.
        It will extract headings and subheadings, create a linked list of contents,
        and place it at the top of the text with a title. Also, adds a '# REFERENCES' section
        at the end of the document and includes it in the TOC.
        """
        lines = text.split('\n')
        toc = [f"# {toc_title}\n"]
        toc_line = 0

        for i, line in enumerate(lines):
            if line.startswith('# '):
                # Main heading
                heading = line[2:].strip()
                toc.append(f"- [{heading}](#{heading.lower().replace(' ', '-')})")
            elif line.startswith('## '):
                # Subheading
                subheading = line[3:].strip()
                toc.append(f"  - [{subheading}](#{subheading.lower().replace(' ', '-')})")

        # Add REFERENCES to TOC and at the end of the document
        toc.append(f"- [REFERENCES](#references)")
        toc_text = '\n'.join(toc)
        complete_text = toc_text + '\n\n' + text + '\n\n# REFERENCES\n'

        return complete_text


    def _replace_glossary_heading(self, text):
        """
        Look for the string "section*{GLOSSARY OF TERMS}" in a given text,
        and if found, replace it with "# GLOSSARY OF TERMS".
        """
        return text.replace("section*{GLOSSARY OF TERMS}", "# GLOSSARY OF TERMS")


    def _convert_latex_list_to_markdown(self, text):
        """
        Convert a LaTeX list in a text to Markdown style.
        The function identifies LaTeX list patterns and replaces them accordingly.
        """
        import re

        # Regular expression to find LaTeX lists
        latex_list_pattern = r"(\\begin\{itemize\})(.*?)(\\end\{itemize\})"
        list_item_pattern = r"\\item\s"


        # Function to convert each LaTeX list to Markdown
        def latex_to_markdown(match):
            list_content = match.group(2)
            # Replace \item with Markdown list item
            markdown_list = re.sub(list_item_pattern, "* ", list_content)
            # Remove extra newlines and spaces
            markdown_list = markdown_list.strip()
            return markdown_list

        # Replace all LaTeX lists in the text with Markdown lists
        converted_text = re.sub(latex_list_pattern, latex_to_markdown, text, flags=re.DOTALL)

        return converted_text